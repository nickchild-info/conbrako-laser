"""Payfast payment gateway service.

Handles signature generation, payment form building, and ITN validation
for the South African Payfast payment gateway.

Docs: https://developers.payfast.co.za/docs
"""
import hashlib
import urllib.parse
from typing import Optional
from decimal import Decimal
from dataclasses import dataclass

from app.core.config import get_settings


# Payfast sandbox and production URLs
PAYFAST_SANDBOX_URL = "https://sandbox.payfast.co.za/eng/process"
PAYFAST_PRODUCTION_URL = "https://www.payfast.co.za/eng/process"

# Valid Payfast ITN source IP ranges (for validation)
PAYFAST_ITN_IP_RANGES = [
    "197.97.145.144/28",
    "41.74.179.192/27",
]


@dataclass
class PayfastPaymentData:
    """Data required to build a Payfast payment form."""
    merchant_id: str
    merchant_key: str
    return_url: str
    cancel_url: str
    notify_url: str
    name_first: str
    name_last: str
    email_address: str
    m_payment_id: str  # Our order ID
    amount: str  # Format: "100.00"
    item_name: str
    item_description: Optional[str] = None
    custom_str1: Optional[str] = None  # Custom field 1
    custom_str2: Optional[str] = None  # Custom field 2
    custom_str3: Optional[str] = None  # Custom field 3
    custom_int1: Optional[int] = None  # Custom integer 1
    signature: Optional[str] = None


def generate_signature(data: dict, passphrase: str = "") -> str:
    """Generate MD5 signature for Payfast payment data.

    The signature is generated by:
    1. Sorting the data alphabetically by key
    2. URL encoding each value
    3. Concatenating as key=value pairs with &
    4. Appending passphrase if provided
    5. MD5 hashing the result

    Args:
        data: Dictionary of payment data (excluding signature)
        passphrase: Payfast passphrase (empty for sandbox)

    Returns:
        MD5 signature string
    """
    # Remove any existing signature and None values
    filtered_data = {k: v for k, v in data.items() if v is not None and k != "signature"}

    # Sort alphabetically
    sorted_data = sorted(filtered_data.items())

    # Build the parameter string
    param_string = "&".join(
        f"{key}={urllib.parse.quote_plus(str(value))}"
        for key, value in sorted_data
    )

    # Append passphrase if provided
    if passphrase:
        param_string += f"&passphrase={urllib.parse.quote_plus(passphrase)}"

    # Generate MD5 hash
    return hashlib.md5(param_string.encode()).hexdigest()


def verify_signature(data: dict, signature: str, passphrase: str = "") -> bool:
    """Verify a Payfast signature matches the data.

    Args:
        data: Dictionary of payment data (excluding signature)
        signature: Signature to verify
        passphrase: Payfast passphrase

    Returns:
        True if signature is valid
    """
    expected_signature = generate_signature(data, passphrase)
    return signature.lower() == expected_signature.lower()


def build_payment_form_data(
    order_id: str,
    amount: Decimal,
    item_name: str,
    customer_email: str,
    customer_first_name: str = "Customer",
    customer_last_name: str = "",
    item_description: Optional[str] = None,
    custom_str1: Optional[str] = None,
    custom_str2: Optional[str] = None,
    custom_str3: Optional[str] = None,
) -> dict:
    """Build payment form data for Payfast.

    Args:
        order_id: Unique order identifier
        amount: Payment amount in ZAR
        item_name: Name of the item/order
        customer_email: Customer's email address
        customer_first_name: Customer's first name
        customer_last_name: Customer's last name
        item_description: Optional item description
        custom_str1-3: Optional custom string fields

    Returns:
        Dictionary with all form fields including signature
    """
    settings = get_settings()

    # Format amount to 2 decimal places
    amount_str = f"{amount:.2f}"

    # Build the data dictionary
    data = {
        "merchant_id": settings.payfast_merchant_id,
        "merchant_key": settings.payfast_merchant_key,
        "return_url": settings.payfast_return_url,
        "cancel_url": settings.payfast_cancel_url,
        "notify_url": settings.payfast_notify_url,
        "name_first": customer_first_name,
        "name_last": customer_last_name,
        "email_address": customer_email,
        "m_payment_id": order_id,
        "amount": amount_str,
        "item_name": item_name[:100],  # Max 100 chars
    }

    # Add optional fields
    if item_description:
        data["item_description"] = item_description[:255]  # Max 255 chars
    if custom_str1:
        data["custom_str1"] = custom_str1[:255]
    if custom_str2:
        data["custom_str2"] = custom_str2[:255]
    if custom_str3:
        data["custom_str3"] = custom_str3[:255]

    # Generate signature
    data["signature"] = generate_signature(data, settings.payfast_passphrase)

    return data


def get_payfast_url() -> str:
    """Get the Payfast URL based on sandbox setting.

    Returns:
        Sandbox or production URL
    """
    settings = get_settings()
    return PAYFAST_SANDBOX_URL if settings.payfast_sandbox else PAYFAST_PRODUCTION_URL


def is_valid_itn_source(ip_address: str) -> bool:
    """Check if an IP address is a valid Payfast ITN source.

    In sandbox mode, we allow all IPs for testing.
    In production, we validate against Payfast's IP ranges.

    Args:
        ip_address: The source IP address

    Returns:
        True if IP is valid
    """
    settings = get_settings()

    # Allow all IPs in sandbox mode
    if settings.payfast_sandbox:
        return True

    # In production, validate against known Payfast IPs
    import ipaddress

    try:
        ip = ipaddress.ip_address(ip_address)
        for ip_range in PAYFAST_ITN_IP_RANGES:
            if ip in ipaddress.ip_network(ip_range):
                return True
    except ValueError:
        pass

    return False


def parse_itn_data(form_data: dict) -> dict:
    """Parse and validate ITN data from Payfast.

    Args:
        form_data: Form data from ITN POST request

    Returns:
        Parsed ITN data dictionary
    """
    return {
        "m_payment_id": form_data.get("m_payment_id"),
        "pf_payment_id": form_data.get("pf_payment_id"),
        "payment_status": form_data.get("payment_status"),
        "item_name": form_data.get("item_name"),
        "amount_gross": form_data.get("amount_gross"),
        "amount_fee": form_data.get("amount_fee"),
        "amount_net": form_data.get("amount_net"),
        "name_first": form_data.get("name_first"),
        "name_last": form_data.get("name_last"),
        "email_address": form_data.get("email_address"),
        "merchant_id": form_data.get("merchant_id"),
        "signature": form_data.get("signature"),
        "custom_str1": form_data.get("custom_str1"),
        "custom_str2": form_data.get("custom_str2"),
        "custom_str3": form_data.get("custom_str3"),
    }


# Payment status constants
class PaymentStatus:
    COMPLETE = "COMPLETE"
    FAILED = "FAILED"
    PENDING = "PENDING"
    CANCELLED = "CANCELLED"
